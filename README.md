# brick-ui-editor

从个人的使用体验出发，总结了部门现有设计工具的一些优点和不足：PM、UE 同学用 Axure 快速产出原型设计，但是可用组件较少，只能描述基本的交互和内容；UI 同学用 sketch measure 产出样式丰富、精确的设计稿，能直接供前端使用，但是严格遵循设计规范，产出较慢，而且完全静态，不提供任何交互。假如在完全规范的理想的流程中，两者是可以各司其职，但实际情况未必如此。

为此，个人设计开发了 Brick Playground。下面请看演示：

Hover 页面上方的控制面板抽屉，可编辑原型稿的名称、作者信息，调整画布的宽高，复制或读取存档。

Hover 页面左侧的示例列表抽屉，其中按交互类别展示了目前 Brick 组件库提供的 20 多种组件。相应的扩展面板展开之后是组件各种业务场景下的示例，可进行 UI 交互；按住 metaKey 会在每个实例上展示交互蒙层，点击即可使用。下面以 Button 组件为例：

页面可见区域大部分是画布。已使用的组件会放置在画布的默认位置。它同样也是可交互的普通组件；按住 metaKey 键也会展示蒙层，可以进行拖拽和编辑。选中的组件展示它的宽高和坐标，同时渲染辅助标线，用于与其它组件对齐定位。右侧可以编辑所有 UI 相关的 prop，针对字符串、布尔值、枚举值等等类型，提供不同的编辑方式。图标类 prop 通过特殊的图标选择器编辑。

在以菜单 Menu 为例。编辑数组类的 prop 时出现弹窗表格，可以修改每项的属性或者推入新的项。

最后展示画布的读写功能。假设完成了如图的交互稿，

可以复制出画布的存档数据，分享给其它同学；如果把画布清空、重置，可以通过粘贴剪贴板中的数据，读取画布内容。所有的编辑都会同步存储在本地，随时刷新都可以恢复。以上就是大致的流程闭环。

如演示可见，产出的原型稿基于团队新组件库 Brick，符合 DLS 规范；同时，在原型中维持组件的交互功能，用户有类所见即所得的使用体验；而且，它可以携带 UI 渲染的来源数据直接供前端开发使用。

希望在一定程度上解决项目数量多、U 同学资源不足的痛点。下面是代码层面的结构说明：

首先对组件库所有可用的原始组件分别处理，产生相应的包装组件。具体处理的逻辑依赖于一套配置，它定义了各个包装组件的信息和允许编辑的 prop 的编辑方式等。

产生的包装组件有 3 个特点：1. 只保留 UI 及数据展示相关的 prop； 2. 接受基本类型 prop 以便序列化、存储，自身内部进行处理，渲染出接受复杂 prop 的原始组件；3. 一些样式和逻辑的覆写（例如 popper，modal 这些相对整个视口定位的组件，为了便于使用需要进行常规定位）。

之后使用通用的高阶组件 wrapDemoComp，产出左侧 demo 列表中的组件实例。它把包装组件包裹在一个 <div> 容器中，渲染与容器等宽高、默认隐藏的交互蒙层，按住 cmd metaKey 时展示蒙层；

点击后，把内部包装组件的各项数据封装成一个对象，推入已使用的组件数据数组。它也是整个项目的数据核心，每项包含：组件的唯一 id、类型、宽高、其它 props、以及相对于画布的坐标。

根据配置，把这个数组的每一项映射为包装组件的实例，再经过处理，作为已使用的组件渲染在画布上。所做的处理包括：包裹实际组件在一个可拖拽的容器内，同样渲染按下 metaKey 才显示的交互蒙层，点击蒙层会给予内部组件「活动」的状态；同时这个蒙层是拖拽行为的触发元素，拖拽时改变元素的 transform transition。

存在活动的组件时，可根据配置中的定义编辑它的坐标、宽高和其它 prop。

以上对组件的更新本质上就是对核心数组对应项的更新。

核心数组和画布宽高、存档名称、作者等数据发生变动时，会被序列化并写入 localStorage，页面刷新时自动恢复；也可以手动读取序列化的结果，也就是前面展示的读取功能。